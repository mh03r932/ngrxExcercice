- dumb / smart componentes
- sharing through @input is a problem because cant share state in siblings only in children
- having state in service is fine but its hard to reason about updating state because multiple componentes can change state

- we will have multiple reducers, actions flow into all reducers, they decide if they want to do something, if not they return the current state unchanged
- if state has to change the state is recreated as a new object, this makes change detection easy since it can be done with reference checking
- this means state is cloned using the spread operator.
- if an array changes we have to use concat
- have to be carefull not to update state by accident
- reducer functions are pure (no sideeffect) which makes them very testable


- use INITIAL_STATE and assing a meaningfull initial state
- root reducer needs to match shape of applicationState (i.e. properties)
- select someting from the store using a query function, we get an observable back
- recommendet to put state stuff of ng-rx into feature-modules
- why use guard if you could use resolver?
-> semantics resolver should return resolved data, however in ngrx we just want to put it into the store

Frage: wann setzt man ngRX ein?
- Subfrage: Was geh√∂rt in den store?

SHARI
Shared state (authentication state)
Hydrated (must be in same state after reloading)
made Available across routes
Retrieved
Impacted (one piece of information is impacted by many components)


- Wenn man die router events auch als event sehen will dasnn added man die router-store extension

link ngconf boilerplate talk,


error handling was not part of the talk. if there is an error in an effect you have to probably add an error action in the effect


